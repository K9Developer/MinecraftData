name: Get Minecraft Items

on:
  schedule:
    - cron: '0 0 * * *'  # Run daily at midnight UTC
  workflow_dispatch:  # Allow manual triggering

jobs:
  get_items:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.PAT }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests
        pip install beautifulsoup4
        pip install Pillow

    - name: Create items directory
      run: mkdir -p items

    - name: Run items script
      run: |
        cat << EOT > get_items.py
        from concurrent.futures import ThreadPoolExecutor, as_completed
        from io import BytesIO
        import json
        from math import sqrt
        import math
        import re
        import time
        import requests
        from bs4 import BeautifulSoup
        from PIL import Image
        
        img_cache = {}
        
        ICON_SIZE = 64
        
        def get_data(row):
            tds = row.find_all("td")
            image_url = tds[0].find("a")
            if image_url.get("href") is not None:
                image_url = image_url["href"]
            else:
                image_url = image_url.find("img")
                if image_url.get("data-src") is not None:
                    image_url = image_url["data-src"]
                else:
                    image_url = image_url["src"]
            mc_id = tds[1].text
            name = tds[2].text.strip().replace("\\n", "")
            return {
                "image_url": image_url,
                "mc_id": mc_id,
                "name": name
            }
        
        
        def get_blocks():
            print("Getting blocks")
            url = "https://minecraft.fandom.com/api.php?action=parse&format=json&prop=text%7Cmodules%7Cjsconfigvars&title=Java_Edition_data_values&text=%7B%7B%3AJava%20Edition%20data%20values%2FBlocks%7D%7D"
            response = requests.get(url)
            data = response.json()
            html = data["parse"]["text"]["*"]
            soup = BeautifulSoup(html, "html.parser")
            print("Got soup")
            table = soup.find("table", attrs={"data-description": "Block IDs"})
            blocks = []
            for row in table.find_all("tr")[1:]:
                block_data = get_data(row)
                block_data["type"] = "block"
                blocks.append(block_data)
                print(f"Got block {block_data['name']}")
            return blocks
        
        def get_item_data(row):
            """Helper function to fetch item data."""
            item_data = {}
            td1 = row.find_all("td")[0]
            item_data["name"] = td1.text.strip()
            td2 = row.find_all("td")[1]
            item_data["mc_id"] = td2.text.strip()
            wiki_url = "https://minecraft.fandom.com" + td1.find("a")["href"]
            
            # Fetch image from wiki page
            res = requests.get(wiki_url)
            soup = BeautifulSoup(res.text, "html.parser")
            figures = soup.find_all("figure", class_="pi-item")
            figure = None
            for f in figures:
                if (t := f.find("a")) is not None:
                    if t.get("href") is not None:
                        g = re.search(r"https:\/\/static.wikia.nocookie.net\/minecraft_gamepedia\/images\/.*?\/.*?\/(.*)\.(:?png|jpg)\/revision.*", t["href"])
                        if g is not None:
                            group = g.group(1)
                            if group.lower().startswith(td2.text.strip()):
                                figure = f
                                break
            if figure is None and figures:
                figure = figures[-1]
            image_url = figure.find("a")["href"] if figure else None
            
            item_data["image_url"] = image_url
            item_data["type"] = "item"
            print(f"Got item {item_data['name']}")
            return item_data
        
        
        def get_items():
            print("Getting items")
            url = "https://minecraft.fandom.com/api.php?action=parse&format=json&prop=text%7Cmodules%7Cjsconfigvars&title=Java_Edition_data_values&text=%7B%7B%3AJava%20Edition%20data%20values%2FItems%7D%7D"
            response = requests.get(url)
            data = response.json()
            html = data["parse"]["text"]["*"]
            soup = BeautifulSoup(html, "html.parser")
            print("Got soup")
            table = soup.find("table", attrs={"data-description": "Item IDs"})
            items = []
        
            # Using ThreadPoolExecutor to parallelize fetching of item data
            with ThreadPoolExecutor(max_workers=20) as executor:
                futures = [executor.submit(get_item_data, row) for row in table.find_all("tr")[1:]]
                for future in as_completed(futures):
                    item_data = future.result()
                    items.append(item_data)
        
            return items
        
        def get_image_PIL(item):
            res = requests.get(item["image_url"])
            im = Image.open(BytesIO(res.content))
            im = im.convert("RGBA")
            bbox = im.getbbox()
            im = im.crop(bbox)
            new_image = Image.new("RGBA", (ICON_SIZE, ICON_SIZE), (0, 0, 0, 0))
            im.thumbnail((ICON_SIZE, ICON_SIZE))
            x_offset = (ICON_SIZE - im.width) // 2
            y_offset = (ICON_SIZE - im.height) // 2
            new_image.paste(im, (x_offset, y_offset), im)
        
            return new_image
        
        def process_block(item, i, width):
            pil_image = get_image_PIL(item)
            x = (i % (width // ICON_SIZE)) * ICON_SIZE
            y = (i // (width // ICON_SIZE)) * ICON_SIZE
            print(f"Processed block {item['name']}")
            return {
                "image": pil_image,
                "position": (x, y),
                "data": {
                    "name": item["name"],
                    "id": item.get("mc_id", ""),
                    "type": item["type"],
                    "offsetX": x,
                    "offsetY": y
                }
            }
        
        def process_item(item, i, width):
            pil_image = get_image_PIL(item)
            x = (i % (width // ICON_SIZE)) * ICON_SIZE
            y = (i // (width // ICON_SIZE)) * ICON_SIZE
            print(f"Processed item {item['name']}")
            return {
                "image": pil_image,
                "position": (x, y),
                "data": {
                    "name": item["name"],
                    "id": item.get("mc_id", ""),
                    "type": item["type"],
                    "offsetX": x,
                    "offsetY": y
                }
            }
        
        def generate_data(block_data, item_data):
            full_data = block_data + item_data
            cells = len(full_data)
            width = int(sqrt(cells)) * ICON_SIZE
            height = math.ceil(cells / (width // ICON_SIZE)) * ICON_SIZE
            atlas = Image.new("RGBA", (width, height))
            processed_data = []
        
            # Process blocks using multithreading
            with ThreadPoolExecutor(max_workers=20) as executor:
                block_futures = [executor.submit(process_block, item, i, width) for i, item in enumerate(block_data)]
                
                for future in as_completed(block_futures):
                    result = future.result()
                    atlas.paste(result["image"], result["position"])
                    processed_data.append(result["data"])
        
            # Process items single-threaded
            for i, item in enumerate(item_data, start=len(block_data)):
                result = process_item(item, i, width)
                atlas.paste(result["image"], result["position"])
                processed_data.append(result["data"])
        
            atlas.save("items/atlas.png")
            with open("items/atlas_metadata.json", "w") as f:
                json.dump(processed_data, f, indent=4)
        
        start = time.time()
        block_data = get_blocks()
        item_data = get_items()
        print(f"Got {len(block_data)} blocks and {len(item_data)} items, generating data")
        print(f"Time taken: {time.time() - start}s")
        generate_data(block_data, item_data)
        print(f"Total time taken: {time.time() - start}s")
        EOT
        python get_items.py

    - name: Commit and push changes
      env:
        PAT: ${{ secrets.PAT }}
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add items/
        git commit -m "Update items data" -a || echo "No changes to commit"
        git push https://${PAT}@github.com/${GITHUB_REPOSITORY}.git HEAD:${GITHUB_REF}
