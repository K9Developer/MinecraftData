name: Get Recipes

on:
  schedule:
    - cron: '0 0 * * *'  # Run daily at midnight UTC
  workflow_dispatch:  # Allow manual triggering

jobs:
  get_items:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        token: ${{ secrets.PAT }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests

    - name: Create recipes directory
      run: mkdir -p recipe_trees

    - name: Run recipes script
      run: |
        cat << EOT > get_rec.py
        import requests
        import zipfile
        import io
        import json
        
        # tree_node_cache = {}
        
        def format_recipe_key(key):
            if "tag" in key:
                return "#"+key["tag"]
            elif "item" in key:
                return key["item"]
            else:
                return key
        
        def format_recipe_keys(keys):
            new_keys = {}
            for key, value in keys.items():
              if type(value) is list: value = value[0] # Important: Sometimes it allows multiple items in the same key, currently we dont handle that
              new_key = format_recipe_key(value)
              new_keys[key] = new_key
            return new_keys
        
        def _get_blocks_to_craft_pattern(recipe):
            keys = recipe["key"]
            format_keys = format_recipe_keys(keys)
            blocks_to_craft = {}
            for elem in "".join(recipe["pattern"]):
                if format_keys.get(elem) is None:
                    continue
                if format_keys[elem] in blocks_to_craft:
                    blocks_to_craft[format_keys[elem]] += 1
                else:
                    blocks_to_craft[format_keys[elem]] = 1
        
            return blocks_to_craft
        
        def _get_blocks_to_craft_ingredients(recipe, key="ingredients"):
            blocks_to_craft = {}
            for ingredient in recipe[key]:
                if "tag" in ingredient:
                    tag = ingredient["tag"]
                    formatted_tag = format_recipe_key(tag)
                    if formatted_tag in blocks_to_craft:
                        blocks_to_craft[formatted_tag] += 1
                    else:
                        blocks_to_craft[formatted_tag] = 1
                elif type(ingredient) is dict and "item" in ingredient:
                    item = ingredient["item"]
                    formatted_item = format_recipe_key(item)
                    if formatted_item in blocks_to_craft:
                        blocks_to_craft[formatted_item] += 1
                    else:
                        blocks_to_craft[formatted_item] = 1
                else:
                    if type(ingredient) is list: ingredient = ingredient[0] # Important: Sometimes it allows multiple items in the same ingredient, currently we dont handle that
                    if ingredient in blocks_to_craft:
                        blocks_to_craft[ingredient] += 1
                    else:
                        blocks_to_craft[ingredient] = 1
            return blocks_to_craft
        
        def _get_blocks_to_craft_ingredient(recipe):
            ingredient = recipe["ingredient"]
            if "tag" in ingredient:
                return {format_recipe_key(ingredient["tag"]): 1}
            elif "item" in ingredient:
                return {format_recipe_key(ingredient["item"]): 1}
            else:
                return {ingredient: 1}
        
        def get_blocks_to_craft(recipe):
            if "pattern" in recipe:
                return [_get_blocks_to_craft_pattern(recipe)]
            elif "ingredients" in recipe:
                return [_get_blocks_to_craft_ingredients(recipe)]
            elif "ingredient" in recipe and type(recipe["ingredient"]) is list:
                return [{key:val} for key, val in _get_blocks_to_craft_ingredients(recipe, "ingredient").items()]
            elif "ingredient" in recipe:
                return [_get_blocks_to_craft_ingredient(recipe)]
            else:
                return None
        
        def get_latest_version_jar():
            versions_url = "https://piston-meta.mojang.com/mc/game/version_manifest_v2.json"
            versions = requests.get(versions_url).json()
            latest_version = versions["versions"][0]
            version_url = latest_version["url"]
            version = requests.get(version_url).json()
            client_url = version["downloads"]["client"]["url"]
            client = requests.get(client_url).content
            jar = zipfile.ZipFile(io.BytesIO(client))
            return jar
        
        def get_version_tags(jar):
            folder = r"data/minecraft/tags/item"
            tags = {}
            for file in jar.namelist():
                if file.startswith(folder) and file.endswith(".json"):
                    with jar.open(file) as f:
                        tag = json.load(f)
                        tag_name = file.split("/")[-1].split(".")[0]
                        tags[tag_name] = tag["values"]
            return tags
        
        jar = get_latest_version_jar()
        tags = get_version_tags(jar)
        data = {}
        folder = "data/minecraft/recipe"
        recipes = []
        for file in jar.namelist():
            if file.startswith(folder) and file.endswith(".json"):
                with jar.open(file) as f:
                    recipe = json.load(f)
                    blocks_to_craft = get_blocks_to_craft(recipe)
                    if blocks_to_craft is None:
                        continue
        
                    for rec in blocks_to_craft:            
                        recipe_data = {}
                        recipe_data["result"] = recipe["result"]
                        recipe_data["blocks_to_craft"] = rec
                        recipe_data["type"] = recipe["type"]
                        if recipe["result"]["id"] not in data:  
                            data[recipe["result"]["id"]] = [recipe_data]
                        else:
                            data[recipe["result"]["id"]].append(recipe_data)
        
        def fix_data(data):
            new_data = {}
            for item, recipes in data.items():
                new_recipes = []
                for recipe in recipes:
                    new_recipe = recipe.copy()
                    new_recipe["blocks_to_craft"] = {}
                    if recipe["result"].get("count") is None:
                        recipe["result"]["count"] = 1
                    target_amount = recipe["result"]["count"]
                    for block, amount in recipe["blocks_to_craft"].items():
                        new_recipe["blocks_to_craft"][block] = amount / target_amount
                    new_recipe["result"]["count"] = 1
                    new_recipes.append(new_recipe)
                new_data[item] = new_recipes
            return new_data
        
        data = fix_data(data)
        with open("data.json", "w") as f:
            json.dump(data, f, indent=4)
        
        def expand_tag_items(tags, items):
            expanded_items = []
            for item in items:
                if item.startswith("#"):
                    expanded_items.extend(expand_tag_items(tags, tags[item[1:].removeprefix("minecraft:")]))
                else:
                    expanded_items.append(item)
            return expanded_items
        
        def get_items_needed(items):
            data = [
                [], []
            ]
            for item, amount in items.items():
                data[0].append(item)
                data[1].append(amount)
            return data
        
        def premu_expanded(expanded, prefix=[]):
            if len(expanded) == 0:
                return [prefix]
            
            prefixes = []
            for item in expanded[0]:
                prefixes.extend(premu_expanded(expanded[1:], prefix + [item]))
            return prefixes
            
        def expand_items(items):
            expanded = []
            for item in items[0]:
                expanded.append(expand_tag_items(tags, [item]))
            options = premu_expanded(expanded)
            return options
        
        def get_action(action):
            if 'crafting' in action:
                return "craft"
            elif 'smelting' in action:
                return "smelt"
            elif 'blasting' in action:
                return "blast"
            elif 'smoking' in action:
                return "smoke"
            elif 'stonecutting' in action:
                return "stonecut"
            elif 'campfire_cooking' in action:
                return "smelt"
            else:
                return "obtain"    
            
        
        def are_intersecting(a, b):
            return len(set(a) & set(b)) > 0
        
        def generate_tree_node(item, amount, prev_item_buffer, item_type=None):
            if item in prev_item_buffer:
                return None
        
            # if item in tree_node_cache:
            #     return tree_node_cache[item]
        
            tree_node = {
                "name": item,
                "amount": amount,
                "type": item_type,
                "paths": []
            }
        
            path_ind = 0
            for option in data[item]:
                if not tree_node:
                    break
                items_needed = get_items_needed(option["blocks_to_craft"])
                expanded_items = expand_items(items_needed)
                for path in expanded_items:
                    if not tree_node:
                        break
                    if len(tree_node["paths"])-1 < path_ind:
                        tree_node["paths"].append([])
                    for ind, path_item in enumerate(path):
                        if not tree_node:
                            break
                        already_in = False
                        for path2 in tree_node["paths"]:
                            for path_item2 in path2:
                                if path_item2["name"] == path_item:
                                    already_in = True
                                    break
                            if already_in:
                                break
                        if already_in:
                            continue
        
                        bad_item = False
                        for future_option in data[path_item] if data.get(path_item) is not None else []:
                            future_items_needed = get_items_needed(future_option["blocks_to_craft"])
                            if are_intersecting(future_items_needed[0], prev_item_buffer) or item in future_items_needed[0]:
                                bad_item = True
                        
                        if bad_item:
                            continue
        
                        if path_item not in data:
                            # Check if path_item is not already in the other paths
        
                            tree_node["paths"][path_ind].append({
                                "name": path_item,
                                "amount": items_needed[1][ind] * amount,
                                "type": get_action(option["type"]),
                                "paths": []
                            })
                        else:
                            prev_item_buffer.append(item)
                            node = generate_tree_node(path_item, items_needed[1][ind] * amount, prev_item_buffer.copy(), get_action(option["type"]))
                            if node is not None:
                                tree_node["paths"][path_ind].append(node)
                            else:
                                tree_node = None
                    path_ind += 1
        
            if tree_node is not None:
                # tree_node_cache[item] = tree_node
                # remove empty paths
                tree_node["paths"] = [path for path in tree_node["paths"] if len(path) > 0]
        
            return tree_node
        
        
        def get_group_titles(tree, titles):
            if len(tree["paths"]) == 0:
                titles.add(tree["name"])
                return
            for path in tree["paths"]:
                if len(path) == 1:
                    titles.add(tree["name"])
                else:
                    for i in path:
                        get_group_titles(i, titles)
        
        def get_item_data(tree, titles, under_parent=None, current_path=[]):
            base_items = {k: [] for k in titles}
            if len(tree["paths"]) == 0:
                p = under_parent if under_parent is not None else tree["name"]
                base_items[p].append({
                    "item_data": {tree["name"]: tree["amount"]},
                    "path_data": current_path
                })
        
            for pind, path in enumerate(tree["paths"]):
                found_parent = tree["name"] in titles
                for iind, i in enumerate(path):
                    data = get_item_data(i, titles, tree["name"] if found_parent and not under_parent else under_parent, current_path + [pind, iind])
                    for k, v in data.items():
                        base_items[k].extend(v)
            return base_items
                    
        def merge_base_items(base_items):
            # Prepare the data for premu_expanded, filtering out empty categories
            category_options = [options for options in base_items.values() if options]
            
            # If all categories are empty, return a single empty result
            if not category_options:
                return [{"path_data": [], "item_data": {}}]
            
            # Generate all combinations using premu_expanded
            all_combinations = premu_expanded(category_options)
            
            # Merge the combinations
            merged_results = []
            for combination in all_combinations:
                merged_item = {
                    "path_data": [],
                    "item_data": {}
                }
                for option in combination:
                    for item_name, item_amount in option["item_data"].items():
                        if item_name not in merged_item["item_data"]:
                            merged_item["item_data"][item_name] = 0
                        merged_item["item_data"][item_name] += item_amount
                        merged_item["path_data"].append(option["path_data"])
                
                merged_results.append(merged_item)
            
            return merged_results
        
        def get_item_tree(item):
            tree = generate_tree_node(item, 1, [])
            if tree is None:
                return None
            get_group_titles(tree, titles := set())
            print(titles)
            base_items = get_item_data(tree, titles)
            base_items = merge_base_items(base_items)
            tree["base_item_paths"] = base_items
            return tree
        
        all_items = set()
        for item in data:
            expanded_items = expand_tag_items(tags, [item])
            for expanded_item in expanded_items:
                all_items.add(expanded_item)
            for recipe in data[item]:
                for block in recipe["blocks_to_craft"]:
                    expanded_items = expand_tag_items(tags, [block])
                    for expanded_item in expanded_items:
                        all_items.add(expanded_item)
        
        for item in all_items.copy():
            if item not in data:
                with open(f"recipe_trees/{item.removeprefix('minecraft:')}.json", "w") as f:
                    json.dump({
                        "name": item,
                        "amount": 1,
                        "parent": None,
                        "type": "obtain"
                    }, f)
                continue
            print(f" [+] Generating tree for {item}")
            tree = get_item_tree(item)
            if tree is None:
                print(f" [!] Failed to generate tree for {item}")
                continue
            with open(f"recipe_trees/{item.removeprefix('minecraft:')}.json", "w") as f:
                json.dump(tree, f)

        EOT
        python get_rec.py

    - name: Commit and push changes
      env:
        PAT: ${{ secrets.PAT }}
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add recipe_trees/
        git commit -m "Update recipe data" -a || echo "No changes to commit"
        git push https://${PAT}@github.com/${GITHUB_REPOSITORY}.git HEAD:${GITHUB_REF}
